{% extends "base.html" %}

{% block title %}FramePack UI{% endblock %}

{% block content %}
<div class="flex flex-col lg:flex-row gap-6"> <!-- Increased gap -->

    <!-- Main Content Area -->
    <div class="flex-grow lg:w-3/4"> <!-- Adjusted width proportions -->
        <h1 class="text-2xl font-bold mb-5 text-gray-700">FramePack</h1> <!-- Reduced size/margin -->

        <!-- Error Display -->
        {% if error %}
            <div id="error-message" class="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-5 rounded-r-lg shadow text-sm" role="alert"> <!-- Reduced margin, added text-sm -->
                <div class="flex justify-between items-center">
                    <div>
                        <strong class="font-bold">Error:</strong>
                        <span class="block sm:inline ml-2">{{ error }}</span>
                    </div>
                    <button type="button" class="text-red-500 hover:text-red-700" onclick="document.getElementById('error-message').style.display='none'">
                        <svg class="fill-current h-5 w-5" role="button" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><title>Close</title><path d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1 1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0 1.698z"/></svg>
                    </button>
                </div>
            </div>
        {% endif %}

        <!-- Directory Selector (Collapsible Logic via presence of 'directory') -->
        <div id="directory-selector" class="bg-white p-4 rounded-lg shadow-md mb-5 {% if directory %}hidden{% endif %}"> <!-- Reduced padding/margin -->
             <h2 class="text-lg font-semibold mb-3 text-gray-700">Select Image Directory</h2> <!-- Reduced size -->
             <form method="POST" action="{{ url_for('index') }}">
                 <div class="flex items-center">
                     <input type="text" name="directory" class="flex-grow border border-gray-300 rounded-l-md px-3 py-1.5 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500" placeholder="/path/to/your/images"> <!-- Adjusted padding/font -->
                     <button type="submit" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-1.5 px-3 rounded-r-md text-sm transition duration-150 ease-in-out">Load Images</button> <!-- Adjusted padding/font -->
                 </div>
             </form>
        </div>
        
        <!-- Directory Display & Batch Toggle (Shown when directory is selected) -->
        {% if directory %}
        <div class="bg-indigo-100 border border-indigo-200 p-3 rounded-lg shadow-sm mb-5 flex justify-between items-center text-sm"> <!-- Reduced padding/margin, added text-sm -->
            <span class="text-indigo-800">Current Directory: <code class="bg-indigo-200 text-indigo-900 px-1.5 py-0.5 rounded text-xs">{{ directory }}</code></span> <!-- Adjusted code style -->
            <div class="flex items-center space-x-2">
                 <!-- Batch Select Toggle Button -->
                 <button id="batch-select-toggle-btn" onclick="toggleBatchSelectMode()" class="text-xs bg-gray-500 hover:bg-gray-600 text-white font-semibold py-1 px-2 rounded-md transition duration-150 ease-in-out">
                     Enable Batch Select
                 </button>
                 <a href="{{ url_for('index') }}" class="text-xs bg-gray-500 hover:bg-gray-600 text-white font-semibold py-1 px-2 rounded-md transition duration-150 ease-in-out">Change Directory</a> <!-- Adjusted size -->
            </div>
        </div>
        {% endif %}

        <!-- Configuration Accordion (Moved Up) -->
        <div id="config-accordion" class="bg-white rounded-lg shadow-md mb-5"> 
            <details class="group">
                 <summary class="flex justify-between items-center font-medium cursor-pointer list-none p-3"> 
                     <span class="text-base text-gray-700">Configuration</span> 
                     <span class="transition group-open:rotate-180 text-gray-500">
                         <svg fill="none" height="20" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="20"><path d="M6 9l6 6 6-6"></path></svg> 
                     </span>
                 </summary>
                 <div class="text-gray-600 mt-0 group-open:animate-fadeIn border-t border-gray-200 p-4 text-sm"> 
                     <form id="configForm" class="space-y-3"> 
                         <div>
                             <label for="cfg-api-servers" class="block text-xs font-medium text-gray-700 mb-1">API Server URLs (one per line):</label> 
                             <textarea id="cfg-api-servers" name="api_servers" rows="3" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"></textarea>
                         </div>
                         <!-- Add other config options here if needed in the future -->
                         <div class="flex justify-end items-center space-x-3 pt-2"> 
                             <span id="config-save-status" class="text-xs"></span> <!-- Status message -->
                             <button type="button" onclick="saveConfig()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-1 px-3 rounded-md text-xs transition duration-150 ease-in-out">Save Config</button> 
                         </div>
                     </form>
                 </div>
            </details>
        </div>

        <!-- Options Accordion (Moved Down) -->
        <div id="options-accordion" class="bg-white rounded-lg shadow-md mb-5"> <!-- Reduced margin -->
            <details id="options-details" class="group">
                 <summary class="flex justify-between items-center font-medium cursor-pointer list-none p-3"> <!-- Reduced padding -->
                     <span class="text-base text-gray-700">Options</span> <!-- Reduced size -->
                     <span class="transition group-open:rotate-180 text-gray-500">
                         <svg fill="none" height="20" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="20"><path d="M6 9l6 6 6-6"></path></svg> <!-- Reduced icon size -->
                     </span>
                 </summary>
                 <div class="text-gray-600 mt-0 group-open:animate-fadeIn border-t border-gray-200 p-4 text-sm"> <!-- Added text-sm -->
                     <form id="optionsForm" class="space-y-3"> <!-- Reduced spacing -->
                         <div>
                             <label for="opt-prompt" class="block text-xs font-medium text-gray-700 mb-1">Default Prompt:</label> <!-- Reduced size -->
                             <textarea id="opt-prompt" name="prompt" rows="2" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm px-2 py-1">{{ options.prompt }}</textarea> <!-- Reduced rows -->
                         </div>
                         <div>
                             <label for="opt-duration" class="block text-xs font-medium text-gray-700 mb-1">Default Duration (seconds):</label> <!-- Reduced size -->
                             <input type="number" id="opt-duration" name="duration" value="{{ options.duration }}" min="1" max="{{ max_duration }}" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                         </div>
                         <div class="flex items-center pt-1"> <!-- Reduced padding -->
                             <input id="opt-use_teacache" name="use_teacache" type="checkbox" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500" {% if options.use_teacache %}checked{% endif %}>
                             <label for="opt-use_teacache" class="ml-2 block text-xs text-gray-900">Use TeaCache (Default)</label> <!-- Reduced size -->
                         </div>
                         
                         <!-- Zoom Slider (Moved Here) -->
                         <div id="zoom-controls" class="flex items-center space-x-3 pt-2">
                             <label for="zoom-slider" class="text-xs font-medium text-gray-700">Image Zoom:</label>
                             <!-- Set initial value from options -->
                             <input type="range" id="zoom-slider" min="80" max="300" value="{{ options.zoom_level }}" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
                             <span id="zoom-value" class="text-xs text-gray-600 w-12 text-right">{{ options.zoom_level }}px</span>
                         </div>

                         <div class="flex justify-end items-center space-x-3 pt-2"> <!-- Reduced padding -->
                             <span id="options-save-status" class="text-sm"></span> <!-- Status message -->
                             <button type="button" onclick="saveOptions()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-1 px-3 rounded-md text-xs transition duration-150 ease-in-out">Save Defaults</button> <!-- Adjusted size -->
                         </div>
                     </form>
                 </div>
            </details>
        </div>

        <!-- Selection Controls (only show if images exist AND batch mode is active) -->
        {% if images %}
        <div id="selection-controls" class="bg-gray-50 p-3 rounded-lg shadow-sm mb-4 flex justify-between items-center hidden"> <!-- Initially hidden -->
            <div class="flex items-center space-x-3">
                <button id="select-all-btn" onclick="toggleSelectAll()" class="text-xs bg-gray-500 hover:bg-gray-600 text-white font-semibold py-1 px-3 rounded-md transition duration-150 ease-in-out">Select All</button>
                <span id="selection-count" class="text-xs text-gray-600">0 images selected</span>
            </div>
            <div class="flex items-center space-x-3">
                 <span id="queue-status-msg" class="text-xs text-blue-600"></span>
                 <button id="queue-selected-btn" onclick="queueSelected()" class="text-xs bg-green-600 hover:bg-green-700 text-white font-semibold py-1 px-3 rounded-md transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed" disabled>Queue Selected</button>
            </div>
        </div>
        {% endif %}

        <!-- Image Grid -->
        {% if images %}
            <div id="image-grid" class="grid gap-4"> 
                {% for image in images %}
                <div class="image-card bg-white rounded-lg shadow-md overflow-hidden cursor-pointer flex flex-col items-center justify-start card-hover-effect" 
                     data-image-path="{{ image.path | e }}"
                     onclick="handleImageClick(this, '{{ image.path | e }}', '{{ image.name | e }}')">
                    <!-- Adjusted image container: aspect ratio and padding -->
                    <div class="w-full aspect-square flex items-center justify-center overflow-hidden p-1 bg-gray-100"> 
                        <img src="{{ url_for('serve_image', filename=image.path) }}" alt="{{ image.name }}" class="max-h-full max-w-full object-contain"> 
                    </div>
                    <!-- Adjusted footer padding and text size -->
                    <div class="p-1.5 w-full text-center bg-gray-50 border-t border-gray-100"> 
                        <p class="text-[11px] text-gray-600 truncate font-medium" title="{{ image.name }}">{{ image.name }}</p> <!-- Smaller font -->
                    </div>
                </div>
                {% endfor %}
            </div>
        {% elif directory %}
            <div class="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 rounded-r-lg shadow text-sm" role="alert"> <!-- Added text-sm -->
                No images found in the selected directory.
            </div>
        {% endif %}
    </div>

    <!-- Sticky Job Status Sidebar -->
    <div class="w-full lg:w-1/4 flex-shrink-0"> 
        <div class="sticky-sidebar bg-gray-100 p-0 rounded-lg"> 
            <div class="bg-white p-3 rounded-lg shadow-md mb-4"> <!-- Server Status Card - Reduced padding -->
                <h2 class="text-base font-semibold mb-2 border-b border-gray-200 pb-1.5 text-gray-700">Server Status</h2> <!-- Reduced size/spacing -->
                <div id="server-status-list" class="space-y-1.5 text-xs max-h-40 overflow-y-auto"> <!-- Reduced spacing/font -->
                    <p class="text-gray-500">Loading server status...</p>
                </div>
            </div>
            <div class="bg-white p-3 rounded-lg shadow-md"> <!-- Job Status Card - Reduced padding -->
                 <div class="flex justify-between items-center mb-2 border-b border-gray-200 pb-1.5">
                     <h2 class="text-base font-semibold text-gray-700">Job Status</h2>
                     <!-- Queue Controls -->
                     <div class="flex space-x-1.5">
                         <button id="run-queue-btn" onclick="runQueue()" title="Resume processing new jobs" class="text-xs bg-green-500 hover:bg-green-600 text-white font-semibold py-0.5 px-2 rounded transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">Run</button>
                         <button id="pause-queue-btn" onclick="pauseQueue()" title="Stop processing new jobs" class="text-xs bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-0.5 px-2 rounded transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">Pause</button>
                         <button id="clear-queue-btn" onclick="clearQueue()" title="Remove all queued/retry jobs" class="text-xs bg-red-500 hover:bg-red-600 text-white font-semibold py-0.5 px-2 rounded transition duration-150 ease-in-out">Clear</button>
                     </div>
                 </div>
                 <div id="job-status-list" class="space-y-2 text-xs max-h-[calc(100vh-20rem)] overflow-y-auto"> <!-- Adjusted max-height -->
                     <p class="text-gray-500">Loading job status...</p>
                 </div>
            </div>
        </div>
    </div>
</div>


<!-- Generation Modal (Tailwind Styled) -->
<div id="generationModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 overflow-y-auto h-full w-full flex items-center justify-center hidden z-50 p-4" aria-labelledby="generationModalLabel" role="dialog" aria-modal="true"> 
    <div class="relative mx-auto p-5 border-0 w-full max-w-lg shadow-xl rounded-lg bg-white"> 
        <div class="flex justify-between items-center border-b border-gray-200 pb-2 mb-4"> <!-- Reduced padding -->
             <h5 class="text-lg font-medium leading-6 text-gray-900" id="generationModalLabel">Generate Video</h5> <!-- Reduced size -->
             <button type="button" class="text-gray-400 bg-transparent hover:bg-gray-200 hover:text-gray-900 rounded-lg text-sm p-1.5 ml-auto inline-flex items-center transition duration-150 ease-in-out" onclick="closeModal()">
                 <svg aria-hidden="true" class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                 <span class="sr-only">Close modal</span>
             </button>
        </div>
        <div class="mt-2"> 
            <form id="generateForm" class="space-y-3"> <!-- Reduced spacing -->
                <input type="hidden" id="modalImagePath" name="image_path">
                <div class="mb-2 text-center"> <!-- Reduced margin -->
                    <label class="block text-xs font-medium text-gray-700 mb-1 text-left">Image:</label> <!-- Reduced size -->
                    <img id="modalImagePreview" src="" alt="Selected Image" class="mt-1 max-h-40 w-auto mx-auto mb-1 rounded border border-gray-200"> <!-- Reduced max-height -->
                    <p id="modalImageName" class="text-center text-xs text-gray-600"></p>
                </div>
                <div>
                    <label for="modalPrompt" class="block text-xs font-medium text-gray-700 mb-1">Prompt:</label> <!-- Reduced size -->
                    <textarea class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm px-2 py-1" id="modalPrompt" name="prompt" rows="3">{{ options.prompt }}</textarea>
                </div>
                <div>
                    <label for="modalDuration" class="block text-xs font-medium text-gray-700 mb-1">Duration (seconds):</label> <!-- Reduced size -->
                    <input type="number" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" id="modalDuration" name="duration" value="{{ options.duration }}" min="1" max="{{ max_duration }}">
                </div>
            </form>
            <div id="modalMessage" class="mt-3 text-sm"></div> <!-- Reduced margin -->
        </div>
        <div class="mt-4 px-0 py-3 sm:flex sm:flex-row-reverse border-t border-gray-200 pt-3"> <!-- Reduced margin/padding -->
            <button type="button" class="w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-3 py-1.5 bg-indigo-600 text-sm font-medium text-white hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 sm:ml-3 sm:w-auto transition duration-150 ease-in-out" onclick="submitGeneration()"> <!-- Reduced padding/font -->
                Generate
            </button>
            <button type="button" class="mt-3 w-full inline-flex justify-center rounded-md border border-gray-300 shadow-sm px-3 py-1.5 bg-white text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 sm:mt-0 sm:ml-3 sm:w-auto transition duration-150 ease-in-out" onclick="closeModal()"> <!-- Reduced padding/font -->
                Cancel
            </button>
        </div>
    </div>
</div>

{% endblock %}

{% block scripts %}
<script>
    const modal = document.getElementById('generationModal');
    const modalImagePath = document.getElementById('modalImagePath');
    const modalImagePreview = document.getElementById('modalImagePreview');
    const modalImageName = document.getElementById('modalImageName');
    const modalPrompt = document.getElementById('modalPrompt');
    const modalDuration = document.getElementById('modalDuration');
    const modalMessage = document.getElementById('modalMessage');
    const configApiServersTextarea = document.getElementById('cfg-api-servers');
    const runQueueBtn = document.getElementById('run-queue-btn');
    const pauseQueueBtn = document.getElementById('pause-queue-btn');
    const clearQueueBtn = document.getElementById('clear-queue-btn');
    const selectAllBtn = document.getElementById('select-all-btn');
    const queueSelectedBtn = document.getElementById('queue-selected-btn');
    const selectionCountSpan = document.getElementById('selection-count');
    const queueStatusMsg = document.getElementById('queue-status-msg');
    const imageGrid = document.getElementById('image-grid'); // Get image grid container
    const zoomSlider = document.getElementById('zoom-slider');
    const zoomValueSpan = document.getElementById('zoom-value');
    const batchSelectToggleBtn = document.getElementById('batch-select-toggle-btn');
    const selectionControlsDiv = document.getElementById('selection-controls');
    const optionsDetails = document.getElementById('options-details'); // Get options details element
    const optionsPromptTextarea = document.getElementById('opt-prompt'); // Get options prompt textarea

    // --- State Variables ---
    let batchSelectModeActive = false;
    const selectedImagePaths = new Set();

    // --- Zoom Control ---
    function updateZoom() {
        if (!imageGrid || !zoomSlider || !zoomValueSpan) return;
        const minWidth = zoomSlider.value;
        imageGrid.style.setProperty('--image-card-min-width', `${minWidth}px`);
        zoomValueSpan.textContent = `${minWidth}px`;
    }

    if (zoomSlider) {
        zoomSlider.addEventListener('input', updateZoom);
        // Set initial zoom level on load - value is set by Flask template now
        // updateZoom(); // Call to apply the initial value from the template
    }

    // --- Batch Select Mode Toggle ---
    function toggleBatchSelectMode() {
        batchSelectModeActive = !batchSelectModeActive;

        if (batchSelectModeActive) {
            // Entering batch mode
            if (batchSelectToggleBtn) {
                batchSelectToggleBtn.textContent = 'Disable Batch Select';
                batchSelectToggleBtn.classList.remove('bg-gray-500', 'hover:bg-gray-600');
                batchSelectToggleBtn.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
            }
            if (selectionControlsDiv) {
                selectionControlsDiv.classList.remove('hidden');
            }
            // Ensure UI is updated (buttons might need enabling/disabling)
            updateSelectionUI(); 
        } else {
            // Exiting batch mode
            if (batchSelectToggleBtn) {
                batchSelectToggleBtn.textContent = 'Enable Batch Select';
                batchSelectToggleBtn.classList.add('bg-gray-500', 'hover:bg-gray-600');
                batchSelectToggleBtn.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
            }
            if (selectionControlsDiv) {
                selectionControlsDiv.classList.add('hidden');
            }
            // Clear selection state and visuals
            selectedImagePaths.clear();
            if (imageGrid) {
                imageGrid.querySelectorAll('.image-card.image-selected').forEach(card => {
                    card.classList.remove('image-selected');
                });
            }
            updateSelectionUI(); // Reset counts and button states
        }
    }

    // --- Image Click Handling ---
    function handleImageClick(cardElement, imagePath, imageName) {
        if (batchSelectModeActive) {
            toggleImageSelection(cardElement);
        } else {
            setupModal(imagePath, imageName);
        }
    }

    // --- Selection State & UI ---
    function updateSelectionUI() {
        const totalImages = imageGrid ? imageGrid.querySelectorAll('.image-card').length : 0;
        const selectedCount = selectedImagePaths.size;

        // Update count display
        if (selectionCountSpan) {
            selectionCountSpan.textContent = `${selectedCount} image${selectedCount !== 1 ? 's' : ''} selected`;
        }

        // Update "Queue Selected" button state
        if (queueSelectedBtn) {
            queueSelectedBtn.disabled = selectedCount === 0;
        }

        // Update "Select All" button text
        if (selectAllBtn) {
            if (totalImages > 0 && selectedCount === totalImages) {
                selectAllBtn.textContent = 'Deselect All';
            } else {
                selectAllBtn.textContent = 'Select All';
            }
        }
    }

    function toggleImageSelection(cardElement) {
        const imagePath = cardElement.dataset.imagePath;
        if (!imagePath) return;

        if (selectedImagePaths.has(imagePath)) {
            selectedImagePaths.delete(imagePath);
            cardElement.classList.remove('image-selected');
        } else {
            selectedImagePaths.add(imagePath);
            cardElement.classList.add('image-selected');
        }
        updateSelectionUI();
    }

    function toggleSelectAll() {
        if (!imageGrid) return;
        const allCards = imageGrid.querySelectorAll('.image-card');
        const totalImages = allCards.length;
        const selectedCount = selectedImagePaths.size;
        const selectAll = selectedCount < totalImages; // If not all are selected, we should select all

        allCards.forEach(card => {
            const imagePath = card.dataset.imagePath;
            if (!imagePath) return;

            const isSelected = selectedImagePaths.has(imagePath);

            if (selectAll && !isSelected) {
                selectedImagePaths.add(imagePath);
                card.classList.add('image-selected');
            } else if (!selectAll && isSelected) {
                selectedImagePaths.delete(imagePath);
                card.classList.remove('image-selected');
            }
        });
        updateSelectionUI();
    }

    async function queueSelected() {
        if (selectedImagePaths.size === 0) return;

        const pathsToQueue = Array.from(selectedImagePaths); // Copy the set
        const defaultPrompt = document.getElementById('opt-prompt').value;
        const defaultDuration = document.getElementById('opt-duration').value;
        const numToQueue = pathsToQueue.length;

        // Disable buttons and show status
        if (queueSelectedBtn) queueSelectedBtn.disabled = true;
        if (selectAllBtn) selectAllBtn.disabled = true;
        if (queueStatusMsg) queueStatusMsg.textContent = `Queuing ${numToQueue} image${numToQueue !== 1 ? 's' : ''}...`;

        const submissionPromises = pathsToQueue.map(imagePath => {
            const formData = new FormData();
            formData.append('image_path', imagePath);
            formData.append('prompt', defaultPrompt);
            formData.append('duration', defaultDuration);
            // Note: use_teacache is implicitly handled by app_options in the backend

            return fetch("{{ url_for('generate') }}", {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (!data.job_id) {
                    console.error(`Failed to queue ${imagePath}: ${data.error || 'Unknown error'}`);
                    return { success: false, path: imagePath, error: data.error || 'Unknown error' };
                }
                return { success: true, path: imagePath, jobId: data.job_id };
            })
            .catch(error => {
                console.error(`Error queuing ${imagePath}:`, error);
                return { success: false, path: imagePath, error: String(error) };
            });
        });

        try {
            const results = await Promise.all(submissionPromises);
            const successfulJobs = results.filter(r => r.success).length;
            const failedJobs = numToQueue - successfulJobs;

            if (queueStatusMsg) {
                 if (failedJobs > 0) {
                     queueStatusMsg.textContent = `Queued ${successfulJobs} image(s). ${failedJobs} failed.`;
                 } else {
                     queueStatusMsg.textContent = `Queued ${successfulJobs} image(s) successfully.`;
                 }
                 // Clear message after a delay
                 setTimeout(() => { if(queueStatusMsg) queueStatusMsg.textContent = ''; }, 4000);
            }

            // Clear selection visually and internally
            if (imageGrid) {
                imageGrid.querySelectorAll('.image-card.image-selected').forEach(card => {
                    card.classList.remove('image-selected');
                });
            }
            selectedImagePaths.clear();

        } catch (error) {
            // This catch block might not be strictly necessary with Promise.all
            // individual errors are handled in the .catch within the map
            console.error("Error during batch queueing:", error);
             if (queueStatusMsg) queueStatusMsg.textContent = 'An error occurred during queuing.';
             setTimeout(() => { if(queueStatusMsg) queueStatusMsg.textContent = ''; }, 4000);
        } finally {
            // Re-enable buttons and update UI
            if (selectAllBtn) selectAllBtn.disabled = false;
            updateSelectionUI(); // This will re-enable queue button if needed (though selection is now clear)
            fetchJobStatus(); // Refresh job list
        }
    }

    function setupModal(imagePath, imageName) {
        modalImagePath.value = imagePath;
        modalImagePreview.src = "{{ url_for('serve_image', filename='') }}" + imagePath; // Use url_for for base path
        modalImageName.textContent = imageName;
        // Reset message and default prompt/duration from current options if needed
        modalPrompt.value = optionsPromptTextarea.value; // Use current default prompt
        modalDuration.value = document.getElementById('opt-duration').value; // Use current default duration
        modalMessage.textContent = '';
        modalMessage.className = 'mt-3 text-sm';
        modal.classList.remove('hidden');

        // --- Auto-focus prompt in modal ---
        requestAnimationFrame(() => {
            modalPrompt.focus();
            // Optional: Select text if you want
            // modalPrompt.select(); 
        });
        // --- End Auto-focus ---
    }

    function closeModal() {
        modal.classList.add('hidden');
    }

    function submitGeneration() {
        const form = document.getElementById('generateForm');
        const formData = new FormData(form);
        
        modalMessage.textContent = 'Submitting job...';
        modalMessage.className = 'mt-3 text-sm p-2 bg-blue-100 text-blue-700 rounded';

        fetch("{{ url_for('generate') }}", {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.job_id) {
                modalMessage.textContent = `Job submitted successfully! ID: ${data.job_id}`;
                modalMessage.className = 'mt-3 text-sm p-2 bg-green-100 text-green-700 rounded';
                fetchJobStatus(); // Refresh job list immediately
                // Close modal after a short delay
                setTimeout(closeModal, 1500);
            } else {
                modalMessage.textContent = `Error: ${data.error || 'Unknown error'}`;
                modalMessage.className = 'mt-3 text-sm p-2 bg-red-100 text-red-700 rounded';
            }
        })
        .catch(error => {
            console.error('Error submitting generation job:', error);
            modalMessage.textContent = `Error submitting job: ${error}`;
            modalMessage.className = 'mt-3 text-sm p-2 bg-red-100 text-red-700 rounded';
        });
    }

    function saveOptions() {
        const optionsForm = document.getElementById('optionsForm');
        const statusSpan = document.getElementById('options-save-status');
        const optionsData = {
            prompt: document.getElementById('opt-prompt').value,
            duration: parseInt(document.getElementById('opt-duration').value, 10),
            use_teacache: document.getElementById('opt-use_teacache').checked,
            zoom_level: parseInt(zoomSlider.value, 10) // Add zoom level
        };

        statusSpan.textContent = 'Saving...';
        statusSpan.className = 'text-sm text-blue-600';

        fetch("{{ url_for('api_save_options') }}", {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(optionsData)
        })
        .then(response => response.json())
        .then(data => {
            if (data.message) {
                statusSpan.textContent = 'Saved!';
                statusSpan.className = 'text-sm text-green-600';
                // Update defaults in the modal generation form if needed
                modalPrompt.value = optionsData.prompt;
                modalDuration.value = optionsData.duration;
                // Optionally update slider value if server corrected it, though unlikely
                // if (zoomSlider.value != data.options.zoom_level) {
                //     zoomSlider.value = data.options.zoom_level;
                //     updateZoom();
                // }
            } else {
                statusSpan.textContent = `Error: ${data.error || 'Failed to save'}`;
                statusSpan.className = 'text-sm text-red-600';
            }
            setTimeout(() => { statusSpan.textContent = ''; }, 2000); // Clear status after 2s
        })
        .catch(error => {
            console.error('Error saving options:', error);
            statusSpan.textContent = 'Error saving!';
            statusSpan.className = 'text-sm text-red-600';
            setTimeout(() => { statusSpan.textContent = ''; }, 2000);
        });
    }

    function saveConfig() {
        const statusSpan = document.getElementById('config-save-status');
        // Read servers from textarea, split by newline, trim whitespace, filter empty lines
        const apiServers = configApiServersTextarea.value
            .split('\n')
            .map(line => line.trim())
            .filter(line => line.length > 0);

        const configData = {
            API_SERVERS: apiServers
            // Add other config fields here if they become editable
        };

        statusSpan.textContent = 'Saving...';
        statusSpan.className = 'text-xs text-blue-600';

        fetch("{{ url_for('api_config') }}", {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(configData)
        })
        .then(response => response.json())
        .then(data => {
            if (data.message) {
                statusSpan.textContent = 'Saved!';
                statusSpan.className = 'text-xs text-green-600';
                // Optionally update UI elements if needed, e.g., refresh server status list
                fetchServerStatus(); 
            } else {
                statusSpan.textContent = `Error: ${data.error || 'Failed to save'}`;
                statusSpan.className = 'text-xs text-red-600';
            }
            setTimeout(() => { statusSpan.textContent = ''; }, 3000); // Clear status after 3s
        })
        .catch(error => {
            console.error('Error saving configuration:', error);
            statusSpan.textContent = 'Error saving!';
            statusSpan.className = 'text-xs text-red-600';
            setTimeout(() => { statusSpan.textContent = ''; }, 3000);
        });
    }

    function fetchConfig() {
        fetch("{{ url_for('api_config') }}")
            .then(response => response.json())
            .then(data => {
                if (data.API_SERVERS && Array.isArray(data.API_SERVERS)) {
                    configApiServersTextarea.value = data.API_SERVERS.join('\n');
                }
                // Populate other config fields if added
            })
            .catch(error => {
                console.error('Error fetching configuration:', error);
                configApiServersTextarea.value = "Error loading configuration.";
            });
    }

    // --- Queue Control Functions ---
    function updateQueueButtons(status) {
        if (status === 'paused') {
            pauseQueueBtn.disabled = true;
            runQueueBtn.disabled = false;
            pauseQueueBtn.classList.add('opacity-50', 'cursor-not-allowed');
            runQueueBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        } else { // running
            pauseQueueBtn.disabled = false;
            runQueueBtn.disabled = true;
            pauseQueueBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            runQueueBtn.classList.add('opacity-50', 'cursor-not-allowed');
        }
    }

    function fetchQueueStatus() {
        fetch("{{ url_for('get_queue_status') }}")
            .then(response => response.json())
            .then(data => {
                updateQueueButtons(data.status);
            })
            .catch(error => console.error('Error fetching queue status:', error));
    }

    function pauseQueue() {
        pauseQueueBtn.disabled = true; // Disable immediately
        fetch("{{ url_for('pause_queue') }}", { method: 'POST' })
            .then(response => response.json())
            .then(data => {
                console.log(data.message);
                updateQueueButtons('paused');
            })
            .catch(error => {
                console.error('Error pausing queue:', error);
                pauseQueueBtn.disabled = false; // Re-enable on error
            });
    }

    function runQueue() {
        runQueueBtn.disabled = true; // Disable immediately
        fetch("{{ url_for('run_queue') }}", { method: 'POST' })
            .then(response => response.json())
            .then(data => {
                console.log(data.message);
                updateQueueButtons('running');
            })
            .catch(error => {
                console.error('Error resuming queue:', error);
                runQueueBtn.disabled = false; // Re-enable on error
            });
    }

    function clearQueue() {
        if (!confirm('Are you sure you want to remove all queued and waiting-to-retry jobs? This cannot be undone.')) {
            return;
        }
        clearQueueBtn.disabled = true;
        clearQueueBtn.textContent = 'Clearing...';
        fetch("{{ url_for('clear_queue') }}", { method: 'POST' })
            .then(response => response.json())
            .then(data => {
                console.log(data.message);
                fetchJobStatus(); // Refresh job list immediately
            })
            .catch(error => console.error('Error clearing queue:', error))
            .finally(() => {
                 clearQueueBtn.disabled = false;
                 clearQueueBtn.textContent = 'Clear';
            });
    }

    // --- Job Status Polling ---
    const jobStatusList = document.getElementById('job-status-list');
    const serverStatusList = document.getElementById('server-status-list');

    function getStatusBadge(status) {
        // Using text-xs for badges
        switch (status) {
            case 'completed': return '<span class="inline-flex items-center bg-green-100 text-green-800 text-xs font-medium px-2 py-0.5 rounded-full">Completed</span>'; // Adjusted padding
            case 'running': return '<span class="inline-flex items-center bg-blue-100 text-blue-800 text-xs font-medium px-2 py-0.5 rounded-full animate-pulse">Running</span>'; // Adjusted padding
            case 'queued': return '<span class="inline-flex items-center bg-yellow-100 text-yellow-800 text-xs font-medium px-2 py-0.5 rounded-full">Queued</span>'; // Adjusted padding
            case 'failed_will_retry': return '<span class="inline-flex items-center bg-orange-100 text-orange-800 text-xs font-medium px-2 py-0.5 rounded-full">Failed (Retrying)</span>'; // Adjusted padding
            case 'failed': return '<span class="inline-flex items-center bg-red-100 text-red-800 text-xs font-medium px-2 py-0.5 rounded-full">Failed</span>'; // Adjusted padding
            case 'cancelling': return '<span class="inline-flex items-center bg-gray-200 text-gray-700 text-xs font-medium px-2 py-0.5 rounded-full">Cancelling</span>'; // Adjusted padding/color
            case 'cancelled': return '<span class="inline-flex items-center bg-gray-200 text-gray-700 text-xs font-medium px-2 py-0.5 rounded-full">Cancelled</span>'; // Adjusted padding/color
            default: return `<span class="inline-flex items-center bg-gray-200 text-gray-700 text-xs font-medium px-2 py-0.5 rounded-full">${status}</span>`; // Adjusted padding/color
        }
    }

    function cancelJob(jobId) {
        const button = document.getElementById(`cancel-btn-${jobId}`);
        if (button) {
            button.textContent = 'Cancelling...';
            button.disabled = true;
            button.classList.add('opacity-50', 'cursor-not-allowed');
        }

        fetch(`/api/jobs/${jobId}/cancel`, { // Use the new endpoint
            method: 'POST',
        })
        .then(response => response.json())
        .then(data => {
            console.log(`Cancel response for ${jobId}:`, data);
            // Refresh status immediately to show 'cancelling' or 'cancelled'
            fetchJobStatus(); 
            // Optionally display a message from 'data.message' or 'data.error'
        })
        .catch(error => {
            console.error(`Error cancelling job ${jobId}:`, error);
            if (button) {
                 button.textContent = 'Cancel Failed';
                 // Re-enable after a delay? Or leave disabled?
                 setTimeout(() => {
                     if(document.getElementById(`cancel-btn-${jobId}`)){ // Check if element still exists
                         document.getElementById(`cancel-btn-${jobId}`).textContent = 'Cancel';
                         document.getElementById(`cancel-btn-${jobId}`).disabled = false;
                         document.getElementById(`cancel-btn-${jobId}`).classList.remove('opacity-50', 'cursor-not-allowed');
                     }
                 }, 2000);
            }
        });
    }


    function fetchJobStatus() {
        fetch("{{ url_for('api_jobs') }}")
            .then(response => response.json())
            .then(data => {
                jobStatusList.innerHTML = ''; // Clear current list
                const jobIds = Object.keys(data).sort((a, b) => {
                    const statusOrder = { 'running': 1, 'cancelling': 2, 'queued': 3, 'failed_will_retry': 4, 'completed': 5, 'failed': 6, 'cancelled': 7 }; // Adjusted order
                    const statusA = statusOrder[data[a].status] || 99;
                    const statusB = statusOrder[data[b].status] || 99;
                    if (statusA !== statusB) return statusA - statusB;
                    // Fallback sort by creation time (newest first)
                    const timeA = data[a].creation_time || '1970-01-01T00:00:00Z'; // Add default for sorting
                    const timeB = data[b].creation_time || '1970-01-01T00:00:00Z';
                    // Attempt date comparison if possible, otherwise string compare
                    try {
                         return new Date(timeB) - new Date(timeA);
                    } catch (e) {
                         return timeB.localeCompare(timeA); 
                    }
                });

                if (jobIds.length === 0) {
                    jobStatusList.innerHTML = '<p class="text-gray-500 text-center py-3 text-xs">No jobs found.</p>'; // Adjusted padding/font
                    return;
                }

                jobIds.forEach(jobId => {
                    const job = data[jobId];
                    const jobElement = document.createElement('div');
                    // Reduced padding/margin for job card
                    jobElement.className = 'bg-white rounded-lg shadow p-2.5 mb-2 hover:shadow-md hover:bg-gray-50 transition duration-150 ease-in-out'; 
                    
                    // Using text-xs for all details
                    let outputFilename = job.output_filename ? `<span class="block text-xs text-gray-500 truncate" title="Output: ${job.output_filename}">Output: ${job.output_filename}</span>` : '';
                    let promptText = job.params.prompt ? `<span class="block text-xs text-gray-500 truncate" title="Prompt: ${job.params.prompt}">Prompt: ${job.params.prompt}</span>` : '';
                    let imageFilename = job.params.image_path ? job.params.image_path.split(/[\\/]/).pop() : 'N/A';
                    let imageText = `<span class="block text-xs text-gray-500 truncate" title="Image: ${imageFilename}">Image: ${imageFilename}</span>`; 
                    let durationText = job.params.duration ? `<span class="block text-xs text-gray-500">Duration: ${job.params.duration}s</span>` : '';
                    let teacacheText = job.params.hasOwnProperty('use_teacache') ? `<span class="block text-xs text-gray-500">TeaCache: ${job.params.use_teacache ? 'On' : 'Off'}</span>` : '';

                    let logText = '';
                    // Log text also uses text-xs
                    if (job.status === 'running' && job.output.length > 0) {
                        logText = `<p class="text-xs text-blue-600 mt-1 truncate" title="${job.output[job.output.length - 1]}">Log: ${job.output[job.output.length - 1]}</p>`;
                    } else if (job.status === 'failed_will_retry' && job.output.length > 0) {
                         logText = `<p class="text-xs text-orange-600 mt-1 truncate" title="${job.output[job.output.length - 1]}">Error: ${job.output[job.output.length - 1]}</p>`;
                    } else if (job.status === 'failed' && job.output.length > 0) {
                         logText = `<p class="text-xs text-red-600 mt-1 truncate" title="${job.output[job.output.length - 1]}">Error: ${job.output[job.output.length - 1]}</p>`;
                    } else if (job.status === 'cancelling' && job.output.length > 0) {
                         logText = `<p class="text-xs text-gray-600 mt-1 truncate" title="${job.output[job.output.length - 1]}">${job.output[job.output.length - 1]}</p>`;
                    } else if (job.status === 'cancelled' && job.output.length > 0) {
                         logText = `<p class="text-xs text-gray-600 mt-1 truncate" title="${job.output[job.output.length - 1]}">${job.output[job.output.length - 1]}</p>`;
                    }

                    // --- Action Buttons/Links ---
                    let actionHtml = '';
                    if (['queued', 'running', 'failed_will_retry'].includes(job.status)) {
                        actionHtml = `<button id="cancel-btn-${jobId}" onclick="cancelJob('${jobId}')" class="text-xs bg-red-500 hover:bg-red-600 text-white font-semibold py-0.5 px-2 rounded transition duration-150 ease-in-out">Cancel</button>`;
                    } else if (job.status === 'cancelling') {
                         actionHtml = `<span class="text-xs text-gray-500 italic">Cancelling...</span>`;
                    } else if (job.status === 'completed' && job.output_filename) {
                        // Use url_for to build the base path for results
                        const resultUrl = "{{ url_for('serve_result', filename='') }}" + job.output_filename;
                        actionHtml = `<a href="${resultUrl}" target="_blank" class="text-xs bg-green-500 hover:bg-green-600 text-white font-semibold py-0.5 px-2 rounded transition duration-150 ease-in-out">View</a>`;
                        // Add a download link as well
                        actionHtml += ` <a href="${resultUrl}" download="${job.output_filename}" class="ml-1 text-xs bg-blue-500 hover:bg-blue-600 text-white font-semibold py-0.5 px-2 rounded transition duration-150 ease-in-out">Download</a>`;
                    }

                    // --- Display Progress ---
                    let progressDisplay = '';
                    if (job.status === 'running' && job.progress !== undefined && job.progress > 0) {
                        progressDisplay = `<span class="text-blue-600 font-medium ml-1">(${job.progress}%)</span>`;
                    }
                    // --- End Display Progress ---

                    // --- Display Detailed Message ---
                    let messageDisplay = '';
                    // Show message for running, cancelling, or failed_will_retry states if available
                    if (['running', 'cancelling', 'failed_will_retry'].includes(job.status) && job.message) {
                         // Truncate long messages
                         const shortMessage = job.message.length > 100 ? job.message.substring(0, 97) + '...' : job.message;
                         messageDisplay = `<div class="text-[10px] text-gray-500 mt-0.5 truncate" title="${job.message}">${shortMessage}</div>`;
                    } else if (job.status === 'failed' && job.message) { // Show final failure message
                         const shortMessage = job.message.length > 100 ? job.message.substring(0, 97) + '...' : job.message;
                         messageDisplay = `<div class="text-[10px] text-red-600 mt-0.5 truncate" title="${job.message}">${shortMessage}</div>`;
                    }
                    // --- End Display Detailed Message ---

                    jobElement.innerHTML = `
                        <div class="flex justify-between items-start mb-1"> <!-- Reduced margin -->
                            <span class="font-semibold text-xs text-gray-700 truncate mr-2" title="Job ID: ${jobId}">${jobId.substring(0, 8)}...</span> <!-- Reduced font -->
                            ${getStatusBadge(job.status)}${progressDisplay}
                        </div>
                        ${messageDisplay}
                        <div class="space-y-0.5 mt-1"> <!-- Reduced spacing/margin -->
                            ${imageText}
                            ${promptText}
                            ${durationText}
                            ${teacacheText}
                            ${outputFilename}
                        </div>
                        ${logText}
                        ${actionHtml ? `<div class="mt-2 text-right">${actionHtml}</div>` : ''} <!-- Actions aligned right -->
                    `;
                    jobStatusList.appendChild(jobElement);
                });
            })
            .catch(error => {
                console.error('Error fetching job status:', error);
                jobStatusList.innerHTML = '<p class="text-red-500 text-center py-3 text-xs">Error loading job status.</p>'; // Adjusted padding/font
            });
    }
    
    function fetchServerStatus() {
        fetch("{{ url_for('api_server_status') }}")
            .then(response => response.json())
            .then(data => {
                serverStatusList.innerHTML = ''; // Clear current list
                const serverUrls = Object.keys(data).sort();

                if (serverUrls.length === 0) {
                    serverStatusList.innerHTML = '<p class="text-gray-500 text-xs">No API servers configured.</p>'; // Reduced font
                    return;
                }

                serverUrls.forEach(serverUrl => {
                    const status = data[serverUrl];
                    const serverElement = document.createElement('div');
                    serverElement.className = 'border-b border-gray-100 pb-1 mb-1'; // Reduced spacing

                    let statusText = '';
                    let statusColor = 'text-gray-500';
                    let availabilityText = '';

                    // Status text uses text-xs
                    if (status.available && status.next_retry_time <= Date.now() / 1000) {
                        statusText = 'Available';
                        statusColor = 'text-green-600 font-semibold text-xs';
                    } else if (!status.available) {
                        statusText = 'Busy';
                        statusColor = 'text-blue-600 font-semibold text-xs';
                    } else { // Available but in backoff
                        statusText = 'Backoff';
                        statusColor = 'text-orange-500 font-semibold text-xs';
                        availabilityText = ` (retry in ${Math.round(status.next_retry_available_in_seconds)}s)`;
                    }

                    serverElement.innerHTML = `
                        <div class="flex justify-between items-center">
                             <span class="font-medium text-xs text-gray-600 truncate mr-2" title="${serverUrl}">${serverUrl}</span>
                             <span class="${statusColor}">${statusText}${availabilityText}</span>
                        </div>
                        <div class="text-[11px] text-gray-500">Fails: ${status.fail_count}</div> <!-- Smaller font -->
                    `;
                    serverStatusList.appendChild(serverElement);
                });
            })
            .catch(error => {
                console.error('Error fetching server status:', error);
                serverStatusList.innerHTML = '<p class="text-red-500 text-xs">Error loading server status.</p>'; // Reduced font
            });
    }

    // --- Server Status & Control ---
    function toggleServer(serverUrl) {
        const button = document.getElementById(`toggle-server-${btoa(serverUrl)}`); // Use base64 for ID safety
        if (button) {
            button.disabled = true;
            button.textContent = '...';
        }

        fetch(`/api/servers/${encodeURIComponent(serverUrl)}/toggle`, { method: 'POST' })
            .then(response => response.json())
            .then(data => {
                console.log(data.message);
                fetchServerStatus(); // Refresh server list to show new state
            })
            .catch(error => {
                console.error(`Error toggling server ${serverUrl}:`, error);
                 if (button) { // Re-enable button on error
                     button.disabled = false;
                     // Restore text based on assumed previous state (might be wrong)
                     button.textContent = button.textContent === 'Disable' ? 'Enable' : 'Disable'; 
                 }
            });
    }

    // Initial fetch and periodic refresh
    fetchConfig(); // Fetch config on load
    fetchQueueStatus(); // Fetch initial queue status
    fetchJobStatus();
    fetchServerStatus();
    setInterval(fetchJobStatus, 5000); // Refresh jobs every 5 seconds
    setInterval(fetchServerStatus, 10000); // Refresh servers every 10 seconds

    // Initial UI update for selection (ensures buttons are correctly disabled initially)
    updateSelectionUI();
    updateZoom(); // Apply initial zoom from template value

    // Close modal on escape key
    document.addEventListener('keydown', function (event) {
        if (event.key === 'Escape') {
            closeModal();
        }
    });

    // Auto-focus prompt when Options accordion opens
    if (optionsDetails && optionsPromptTextarea) {
        optionsDetails.addEventListener('toggle', (event) => {
            if (event.target.open) {
                // Use requestAnimationFrame to ensure focus works after animation/rendering
                requestAnimationFrame(() => {
                    optionsPromptTextarea.focus();
                    // Optional: Select text
                    // optionsPromptTextarea.select(); 
                });
            }
        });
    }

</script>
{% endblock %}
